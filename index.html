// --- 4. MAIN APP ---
export default function App() {
  const [names, setNames] = useState(defaultNames); const [inputText, setInputText] = useState(defaultNames.join('\n'));
  const [savedLists, setSavedLists] = useState({}); const [newListName, setNewListName] = useState("");
  const [currentThemeId, setCurrentThemeId] = useState('modern'); const [isSpinning, setIsSpinning] = useState(false);
  const [winner, setWinner] = useState(null); const [winnerHistory, setWinnerHistory] = useState([]);
  const [soundEnabled, setSoundEnabled] = useState(true); const [soundTheme, setSoundTheme] = useState('standard');
  const [mysteryMode, setMysteryMode] = useState(false); const [showSettings, setShowSettings] = useState(false);
  const [projectorMode, setProjectorMode] = useState(false); const [showTimer, setShowTimer] = useState(false);
  const [hubImage, setHubImage] = useState(null); const [showHelp, setShowHelp] = useState(false);
  const [showImport, setShowImport] = useState(false); const [showGroups, setShowGroups] = useState(false);
  
  // Game Modes
  const [battleMode, setBattleMode] = useState(false);
  const [battleStage, setBattleStage] = useState('idle');
  const [battleContestants, setBattleContestants] = useState([null, null]);
  
  // Bloom's Mode: 'off', 'solo' (Bloom's Only), 'dual' (Name + Bloom's)
  const [bloomMode, setBloomMode] = useState('off'); 
  const [bloomWinner, setBloomWinner] = useState(null);

  // Scoreboard State
  const [activeTeams, setActiveTeams] = useState([]); const [teamScores, setTeamScores] = useState([]);
  
  const fileInputRef = useRef(null); 
  const canvasRef = useRef(null); // Left Wheel (Students or Bloom Solo)
  const canvasRef2 = useRef(null); // Right Wheel (Bloom Dual)
  const confettiCanvasRef = useRef(null);
  const containerRef = useRef(null); const audioCtxRef = useRef(null); 
  
  // Rotation Refs
  const rotationRef = useRef(0);
  const rotationRef2 = useRef(0); // Bloom's Rotation
  const velocityRef = useRef(0); 
  const velocityRef2 = useRef(0); // Bloom's Velocity
  const lastTickRef = useRef(0); 
  const isSpinningRef = useRef(false); 
  const pointerRef = useRef(0);
  const pointerRef2 = useRef(0); 

  const theme = THEMES[currentThemeId];

  useEffect(() => { const saved = localStorage.getItem('spinner_lists'); if(saved) setSavedLists(JSON.parse(saved)); }, []);
  const saveList = () => { if(!newListName.trim())return; const u={...savedLists,[newListName]:names}; setSavedLists(u); localStorage.setItem('spinner_lists',JSON.stringify(u)); setNewListName(""); };
  const loadList = (k) => { if(savedLists[k]) { setNames(savedLists[k]); setInputText(savedLists[k].join('\n')); } };
  const deleteList = (k) => { const u={...savedLists}; delete u[k]; setSavedLists(u); localStorage.setItem('spinner_lists',JSON.stringify(u)); };
  const updateNames = (t) => { setInputText(t); setNames(t.split('\n').filter(n=>n.trim())); };
  const performImport = (l) => { setNames(l); setInputText(l.join('\n')); setShowImport(false); };
  const shuffleNames = () => { const s=[...names].sort(()=>Math.random()-0.5); setInputText(s.join('\n')); setNames(s); };
  const removeWinner = () => { if(!winner)return; const n=names.filter(x=>x!==winner); setInputText(n.join('\n')); setNames(n); setWinner(null); setBloomWinner(null); };
  const handleImageUpload = (e) => { const f=e.target.files[0]; if(f){ const r=new FileReader(); r.onload=(evt)=>{ const i=new Image(); i.onload=()=>{setHubImage(i); if(canvasRef.current)drawWheel(canvasRef.current, bloomMode === 'solo' ? bloomsLevels : names, rotationRef.current, pointerRef.current, mysteryMode);}; i.src=evt.target.result; }; r.readAsDataURL(f); } };
  const handleStartScoring = (g) => { setActiveTeams(g); setTeamScores(new Array(g.length).fill(0)); setShowGroups(false); };
  const handleUpdateScore = (i,c) => { const n=[...teamScores]; n[i]+=c; setTeamScores(n); if(soundEnabled) playSound('tick', audioCtxRef, soundTheme); };

  // --- CYCLE BLOOM MODES ---
  const toggleBloomMode = () => {
      setBattleMode(false);
      if (bloomMode === 'off') setBloomMode('solo');
      else if (bloomMode === 'solo') setBloomMode('dual');
      else setBloomMode('off');
  };

  // --- GENERIC DRAW FUNCTION ---
  const drawWheel = (canvas, items, currentRotation, currentPointer, isMystery) => {
    if (!canvas) return; 
    let size = 300; 
    // Resize based on mode
    const isDual = bloomMode === 'dual';
    if (isDual && containerRef.current && containerRef.current.offsetWidth > 0) {
        size = Math.min(containerRef.current.offsetWidth / 2.2, containerRef.current.offsetHeight) * 0.95;
    } else if (containerRef.current && containerRef.current.offsetWidth > 0) {
        size = Math.min(containerRef.current.offsetWidth, containerRef.current.offsetHeight) * 0.95;
    }
    if (size < 50) size = 300;
    if (canvas.width !== size || canvas.height !== size) { canvas.width = size; canvas.height = size; }
    
    const ctx = canvas.getContext('2d'); if (!ctx) return;
    const { width, height } = canvas; const cx = width / 2; const cy = height / 2; const radius = Math.max(0, width / 2 - 25);
    ctx.clearRect(0, 0, width, height);
    
    if (items.length === 0) { ctx.fillStyle = theme.text; ctx.font = "16px sans-serif"; ctx.textAlign = "center"; ctx.fillText("Add items!", cx, cy); return; }
    
    items.forEach((name, i) => {
      const start = i * (2 * Math.PI / items.length) + currentRotation; const end = (i + 1) * (2 * Math.PI / items.length) + currentRotation;
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, radius, start, end); ctx.fillStyle = theme.colors[i % theme.colors.length]; ctx.fill();
      const g = ctx.createRadialGradient(cx, cy, radius * 0.2, cx, cy, radius); g.addColorStop(0, 'rgba(255,255,255,0.15)'); g.addColorStop(1, 'rgba(0,0,0,0.15)'); ctx.fillStyle = g; ctx.fill();
      ctx.strokeStyle = theme.bg; ctx.lineWidth = 2; ctx.stroke();
      ctx.save(); ctx.translate(cx, cy); ctx.rotate(start + (end - start) / 2); ctx.textAlign = "right"; ctx.fillStyle = "#fff"; ctx.font = `bold ${Math.max(12, Math.min(24, 250 / items.length))}px sans-serif`; ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 4; 
      // Only hide text if mystery mode AND it's the student wheel (not bloom's)
      const shouldHide = isMystery && isSpinningRef.current && items === names;
      ctx.fillText(shouldHide ? "?" : name.substring(0, 18), radius - 20, 6); ctx.restore();
    });
    items.forEach((_, i) => { const a = i * (2 * Math.PI / items.length) + currentRotation; ctx.save(); ctx.translate(cx, cy); ctx.rotate(a); ctx.beginPath(); ctx.arc(radius - 2, 0, 4, 0, Math.PI * 2); const pg = ctx.createRadialGradient(radius - 5, -2, 0, radius - 2, 0, 6); pg.addColorStop(0, '#ffffff'); pg.addColorStop(1, '#64748b'); ctx.fillStyle = pg; ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 3; ctx.fill(); ctx.restore(); });
    
    ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, 35, 0, 2 * Math.PI); ctx.closePath(); ctx.clip();
    if (hubImage && items === names) { ctx.drawImage(hubImage, cx - 35, cy - 35, 70, 70); } else { const hg = ctx.createRadialGradient(cx, cy, 10, cx, cy, 35); hg.addColorStop(0, '#fef3c7'); hg.addColorStop(1, '#b45309'); ctx.fillStyle = hg; ctx.fill(); ctx.save(); ctx.translate(cx, cy); ctx.beginPath(); for (let i = 0; i < 5; i++) { ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * 18, -Math.sin((18 + i * 72) * Math.PI / 180) * 18); ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * 8, -Math.sin((54 + i * 72) * Math.PI / 180) * 8); } ctx.closePath(); ctx.fillStyle = "#fff"; ctx.shadowColor = "rgba(180, 83, 9, 0.5)"; ctx.shadowBlur = 5; ctx.fill(); ctx.restore(); } ctx.restore();
    ctx.beginPath(); ctx.arc(cx, cy, 35, 0, 2 * Math.PI); ctx.strokeStyle = "#b45309"; ctx.lineWidth = 4; ctx.stroke();
    
    ctx.save(); ctx.translate(width - 10, cy); ctx.rotate(currentPointer); ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(-40, 0); ctx.lineTo(0, 15); ctx.closePath(); ctx.fillStyle = theme.text; ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 5; ctx.fill(); ctx.restore();
  };

  const spin = () => {
    if (isSpinning || (bloomMode !== 'solo' && names.length < 2)) return;
    setWinner(null);
    setBloomWinner(null); 
    if (battleMode && battleStage === 'idle') {
        setBattleStage('spinning1');
        setBattleContestants([null, null]);
    }
    
    velocityRef.current = 0.4 + Math.random() * 0.4;
    
    // In Dual Mode, spin second wheel too
    if (bloomMode === 'dual') {
        velocityRef2.current = 0.4 + Math.random() * 0.3;
    }

    isSpinningRef.current = true;
    setIsSpinning(true);
  };

  // --- ANIMATION LOOP ---
  useEffect(() => {
    if (!isSpinning) return;
    let af;
    const animate = () => {
        // --- 1. MAIN WHEEL PHYSICS ---
        pointerRef.current *= 0.85;
        if (velocityRef.current > 0.002) {
            velocityRef.current *= 0.985;
            rotationRef.current += velocityRef.current;
            if (rotationRef.current >= Math.PI * 2) rotationRef.current -= Math.PI * 2;
            
            // Sound (Only if main wheel is spinning)
            const currentList = bloomMode === 'solo' ? bloomsLevels : names;
            if (soundEnabled && currentList.length > 0) {
                 const slice = (2 * Math.PI) / currentList.length; const passed = Math.floor(rotationRef.current / slice);
                 if (passed !== lastTickRef.current) { playSound('tick', audioCtxRef, soundTheme); lastTickRef.current = passed; pointerRef.current = 0.3 + Math.random() * 0.1; }
            }
        } else {
            velocityRef.current = 0;
        }

        // --- 2. DUAL WHEEL PHYSICS ---
        if (bloomMode === 'dual') {
            pointerRef2.current *= 0.85;
            if (velocityRef2.current > 0.002) {
                velocityRef2.current *= 0.985;
                rotationRef2.current += velocityRef2.current;
                if (rotationRef2.current >= Math.PI * 2) rotationRef2.current -= Math.PI * 2;
            } else {
                velocityRef2.current = 0;
            }
        }

        // --- 3. DRAW ---
        const mainList = bloomMode === 'solo' ? bloomsLevels : names;
        drawWheel(canvasRef.current, mainList, rotationRef.current, pointerRef.current, mysteryMode);
        
        if (bloomMode === 'dual') {
            drawWheel(canvasRef2.current, bloomsLevels, rotationRef2.current, pointerRef2.current, false);
        }

        // --- 4. CHECK FINISH ---
        if (velocityRef.current === 0 && (bloomMode !== 'dual' || velocityRef2.current === 0)) {
            isSpinningRef.current = false; 
            pointerRef.current = 0;
            pointerRef2.current = 0;
            setIsSpinning(false);
            
            // Calc Main Winner
            let w = null;
            if (mainList.length > 0) { 
                const slice = (2 * Math.PI) / mainList.length; 
                let p = (0 - rotationRef.current) % (2 * Math.PI); if (p < 0) p += 2 * Math.PI; 
                const i = Math.floor(p / slice); if (i >= 0 && i < mainList.length) w = mainList[i]; 
            }

            // Calc Dual Winner
            let bw = null;
            if (bloomMode === 'dual') {
                const slice = (2 * Math.PI) / bloomsLevels.length;
                let p = (0 - rotationRef2.current) % (2 * Math.PI); if (p < 0) p += 2 * Math.PI; 
                const i = Math.floor(p / slice); if (i >= 0 && i < bloomsLevels.length) bw = bloomsLevels[i]; 
            }

            // Battle Logic (Self-Match Fix)
            if (battleMode && battleStage === 'spinning2' && w === battleContestants[0]) {
                velocityRef.current = 0.05 + Math.random() * 0.05; 
                af = requestAnimationFrame(animate);
                return;
            }

            if (battleMode) {
                if (battleStage === 'spinning1') {
                    setBattleContestants([w, null]); setBattleStage('waiting');
                    if (soundEnabled) playSound('tick', audioCtxRef, soundTheme);
                    setTimeout(() => {
                        setBattleStage('spinning2'); velocityRef.current = 0.4 + Math.random() * 0.4; isSpinningRef.current = true; setIsSpinning(true);
                    }, 1000);
                } else if (battleStage === 'spinning2') {
                    setBattleContestants(prev => [prev[0], w]); setBattleStage('finished');
                    if (soundEnabled) playSound('win', audioCtxRef, soundTheme); FireConfetti(confettiCanvasRef.current);
                }
            } else if (w) {
                setWinner(w);
                if (bw) setBloomWinner(bw); // Set Dual Winner
                
                // Add to history (only if it's a student)
                if (bloomMode !== 'solo') {
                    const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    setWinnerHistory(p => [{name: w, time: ts}, ...p].slice(0, 10));
                }
                
                if (soundEnabled) playSound('win', audioCtxRef, soundTheme);
                setTimeout(() => FireConfetti(confettiCanvasRef.current), 10);
            }
        } else {
            af = requestAnimationFrame(animate);
        }
    };
    animate();
    return () => cancelAnimationFrame(af);
  }, [isSpinning, names, soundEnabled, mysteryMode, soundTheme, battleMode, battleStage, battleContestants, bloomMode]);

  // Redraw on resize/mode change
  useEffect(() => { 
      if (!isSpinning) {
          const mainList = bloomMode === 'solo' ? bloomsLevels : names;
          drawWheel(canvasRef.current, mainList, rotationRef.current, pointerRef.current, mysteryMode);
          if (bloomMode === 'dual') drawWheel(canvasRef2.current, bloomsLevels, rotationRef2.current, pointerRef2.current, false);
      }
  }, [names, currentThemeId, mysteryMode, isSpinning, hubImage, bloomMode]);

  useEffect(() => { const k = (e) => { if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return; if (e.code === 'Space') { e.preventDefault(); if (winner) setWinner(null); else if (battleStage === 'finished') setBattleStage('idle'); else if (!isSpinning) spin(); } if (e.code === 'Escape') { if (winner) setWinner(null); else if (battleStage === 'finished') setBattleStage('idle'); else { setShowHelp(false); setShowImport(false); setShowGroups(false); setProjectorMode(false); } } }; window.addEventListener('keydown', k); return () => window.removeEventListener('keydown', k); }, [winner, isSpinning, projectorMode, names, showHelp, showImport, showGroups, battleStage]);

  const cssVariables = {
    '--bg-color': theme.bg, '--text-color': theme.text,
    '--sidebar-bg': theme.sidebar, '--accent-color': theme.accent,
    '--grad-start': theme.colors[0], '--grad-end': theme.colors[1]
  };

  const styles = `
    body { margin: 0; overflow: hidden; -webkit-tap-highlight-color: transparent; }
    .app { display: flex; height: 100vh; font-family: 'Segoe UI', system-ui, sans-serif; background-color: var(--bg-color); color: var(--text-color); transition: background-color 0.3s ease; user-select: none; }
    .sidebar { width: 320px; background-color: var(--sidebar-bg); border-right: 1px solid rgba(128,128,128,0.2); display: flex; flex-direction: column; z-index: 20; transition: all 0.3s; }
    .sidebar.projector-hidden { width: 0; opacity: 0; padding: 0; overflow: hidden; border: none; }
    .sidebar.closed { transform: translateX(-100%); position: fixed; height: 100%; }
    .sidebar.open { transform: translateX(0); position: fixed; height: 100%; box-shadow: 5px 0 20px rgba(0,0,0,0.5); }
    .main { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: space-between; position: relative; padding: 16px; overflow: hidden; }
    .projector-btn { position: absolute; top: 16px; right: 16px; z-index: 30; background: var(--sidebar-bg); border-radius: 50%; padding: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); color: var(--text-color); border: 1px solid rgba(128,128,128,0.2); }
    .projector-btn:hover { background-color: rgba(128,128,128,0.1); transform: scale(1.1); }
    .wheel-container { flex: 1; display: flex; align-items: center; justify-content: center; width: 100%; min-height: 0; margin-bottom: 10px; gap: 20px; }
    .btn { background: none; border: none; cursor: pointer; color: inherit; display: flex; align-items: center; gap: 8px; padding: 10px; border-radius: 8px; font-weight: 600; font-size: 0.95rem; transition: 0.2s; }
    .btn:hover { background-color: rgba(128,128,128,0.15); }
    .btn:active { transform: scale(0.96); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background-color: var(--accent-color); color: #fff; padding: 18px 48px; font-size: 1.5rem; border-radius: 50px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); white-space: nowrap; z-index: 10; margin-bottom: 20px; }
    .btn-primary:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-2px); }
    .input-area { flex: 1; padding: 16px; display: flex; flex-direction: column; gap: 12px; overflow-y: auto; }
    .textarea { width: 100%; height: 100%; min-height: 150px; background: rgba(128,128,128,0.05); border: 1px solid rgba(128,128,128,0.2); color: inherit; padding: 12px; border-radius: 8px; resize: none; font-family: monospace; outline: none; font-size: 16px; }
    .textarea:focus { border-color: var(--accent-color); }
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 50; backdrop-filter: blur(5px); padding: 20px; }
    .modal { background: var(--sidebar-bg); padding: 32px; border-radius: 24px; text-align: center; max-width: 400px; width: 100%; box-shadow: 0 20px 50px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); }
    .winner-name { font-size: clamp(2rem, 5vw, 3.5rem); font-weight: 800; margin: 16px 0; background: linear-gradient(45deg, var(--grad-start), var(--grad-end)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; word-break: break-word; line-height: 1.1; }
    .section-title { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; opacity: 0.7; margin-bottom: 8px; display: block; font-weight: 700; }
    .list-item { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(128,128,128,0.1); border-radius: 6px; font-size: 0.9rem; margin-bottom: 6px; }
    .theme-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
    .theme-btn { padding: 10px; border: 1px solid rgba(128,128,128,0.2); border-radius: 6px; text-align: left; font-size: 0.85rem; cursor: pointer; transition: 0.2s; }
    .theme-btn:hover { border-color: var(--accent-color); }
    .mobile-toggle { position: absolute; top: 16px; left: 16px; z-index: 30; background: var(--sidebar-bg); border-radius: 50%; padding: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); color: var(--text-color); }
    @media (min-width: 769px) { .sidebar { transform: translateX(0) !important; position: relative !important; height: 100% !important; } .mobile-toggle { display: none; } }
  `;

  return (
    <div className="app" style={cssVariables}>
        <style>{styles}</style>
        <canvas ref={confettiCanvasRef} style={{position: 'fixed', inset: 0, pointerEvents: 'none', zIndex: 50}} />
        <button onClick={() => setShowSettings(true)} className="mobile-toggle btn"><Icons.Settings /></button>

        <div className={`sidebar ${showSettings ? 'open' : 'closed'} ${projectorMode ? 'projector-hidden' : ''}`}>
            <div style={{padding: '20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom: '1px solid rgba(128,128,128,0.1)'}}>
                 <h1 style={{margin:0, fontSize: '1.25rem', fontWeight:800, background: `linear-gradient(to right, ${theme.accent}, ${theme.colors[0]})`, WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent'}}>Class Spinner</h1>
                 <div style={{display:'flex', gap: 4}}>
                    <button className="btn" onClick={() => setShowHelp(true)} title="Help" style={{padding: 8}}><Icons.HelpCircle /></button>
                    <button className="btn" onClick={() => setProjectorMode(true)} title="Projector Mode" style={{padding: 8}}><Icons.Maximize /></button>
                 </div>
            </div>
            <div className="input-area">
                <div>
                    <span className="section-title">Tools</span>
                    <div style={{display:'flex', gap:8, flexWrap: 'wrap'}}>
                        <button onClick={shuffleNames} className="btn" style={{background: 'rgba(128,128,128,0.1)', flex:'1 1 40%'}}><Icons.Shuffle/> Shuffle</button>
                        <button onClick={() => setMysteryMode(!mysteryMode)} className="btn" style={{background: mysteryMode ? theme.accent : 'rgba(128,128,128,0.1)', color: mysteryMode ? '#fff' : 'inherit', flex:'1 1 40%'}}>
                           {mysteryMode ? <Icons.EyeOff/> : <Icons.Eye/>} {mysteryMode ? 'Mystery' : 'Visible'}
                        </button>
                        
                        {/* TOGGLE: BATTLE MODE */}
                        <button onClick={() => {setBattleMode(!battleMode); setBloomMode('off'); setBattleStage('idle');}} className="btn" style={{background: battleMode ? '#f59e0b' : 'rgba(128,128,128,0.1)', color: battleMode ? '#fff' : 'inherit', flex:'1 1 40%'}}>
                           <Icons.Swords/> {battleMode ? 'Battle' : 'Battle'}
                        </button>

                        {/* TOGGLE: BLOOM'S MODE (CYCLES) */}
                        <button onClick={toggleBloomMode} className="btn" style={{background: bloomMode !== 'off' ? '#3b82f6' : 'rgba(128,128,128,0.1)', color: bloomMode !== 'off' ? '#fff' : 'inherit', flex:'1 1 40%'}}>
                           <Icons.Brain/> {bloomMode === 'solo' ? "Bloom's" : bloomMode === 'dual' ? "Name+" : "Bloom's"}
                        </button>

                        <button onClick={() => setShowImport(true)} className="btn" style={{background: 'rgba(128,128,128,0.1)', flex:'1 1 40%'}}><Icons.Clipboard/> Import</button>
                        <button onClick={() => setShowGroups(true)} className="btn" style={{background: 'rgba(128,128,128,0.1)', flex:'1 1 40%'}}><Icons.Users/> Teams</button>
                        <button onClick={() => setShowTimer(!showTimer)} className="btn" style={{background: showTimer ? theme.accent : 'rgba(128,128,128,0.1)', color: showTimer ? '#fff' : 'inherit', flex:'1 1 40%'}}><Icons.Clock/> Timer</button>
                    </div>
                </div>
                <div><span className="section-title">Names ({names.length})</span><textarea value={inputText} onChange={(e) => updateNames(e.target.value)} className="textarea" placeholder="Enter names..."/></div>
                <div style={{marginTop: 8}}>
                    <span className="section-title">Theme</span>
                    <div className="theme-grid">{Object.entries(THEMES).map(([id, t]) => (<button key={id} onClick={() => setCurrentThemeId(id)} className="theme-btn" style={{background: currentThemeId === id ? theme.accent : 'transparent', color: currentThemeId === id ? '#fff' : 'inherit', borderColor: currentThemeId === id ? theme.accent : 'rgba(128,128,128,0.2)'}}><span style={{width:10, height:10, borderRadius:'50%', background: t.colors[1], display:'inline-block', marginRight: 6}}></span>{t.name}</button>))}</div>
                </div>
                <div style={{marginTop: 20}}>
                     <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 8}}><span className="section-title">Sound Pack</span><button onClick={() => setSoundEnabled(!soundEnabled)} className="btn" style={{padding: 4}}> {soundEnabled ? <Icons.Volume2/> : <Icons.VolumeX/>} </button></div>
                     <div style={{display:'flex', gap: 4, background:'rgba(128,128,128,0.1)', padding: 4, borderRadius: 8}}>{['standard', 'arcade', 'spooky'].map(s => (<button key={s} onClick={() => setSoundTheme(s)} style={{flex: 1, padding: '6px 0', border: 'none', borderRadius: 4, background: soundTheme === s ? theme.accent : 'transparent', color: soundTheme === s ? '#fff' : 'inherit', fontSize: '0.8rem', textTransform: 'capitalize', cursor: 'pointer', fontWeight: 600}}>{s}</button>))}</div>
                </div>
                <div style={{marginTop: 20}}>
                     <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 8}}><span className="section-title">Session History</span>{winnerHistory.length > 0 && <button onClick={() => setWinnerHistory([])} style={{fontSize: '0.7rem', color: '#ef4444', background: 'none', border:'none', cursor:'pointer'}}>Clear</button>}</div>
                     <div style={{maxHeight: 120, overflowY: 'auto', background: 'rgba(128,128,128,0.05)', borderRadius: 8, padding: 8}}>{winnerHistory.length === 0 && <div style={{fontSize: '0.8rem', opacity: 0.5, fontStyle: 'italic', textAlign: 'center'}}>No winners yet.</div>}{winnerHistory.map((item, i) => (<div key={i} style={{fontSize: '0.85rem', display:'flex', justifyContent:'space-between', padding:'4px 0', borderBottom: '1px solid rgba(128,128,128,0.1)'}}><span>{item.name}</span><span style={{opacity: 0.5, fontSize: '0.75rem'}}>{item.time}</span></div>))}</div>
                </div>
            </div>
        </div>

        <div className="main">
            {projectorMode && <button onClick={() => setProjectorMode(false)} className="projector-btn btn" title="Exit Projector Mode"><Icons.Minimize /></button>}
            <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/*" style={{ display: 'none' }} />
            {showTimer && <Timer audioCtx={audioCtxRef} onClose={() => setShowTimer(false)} />}
            {activeTeams.length > 0 && <Scoreboard teams={activeTeams} scores={teamScores} onUpdateScore={handleUpdateScore} onClose={() => setActiveTeams([])} />}

            {/* BATTLE DISPLAY (SIDES) */}
            {battleMode && (
                <>
                    <div style={{position: 'absolute', top: '50%', left: '20px', transform: 'translateY(-50%)', zIndex: 10, transition: 'all 0.5s', opacity: battleContestants[0] ? 1 : 0.3}}>
                        <div style={{background: theme.colors[0], color: 'white', padding: '20px', borderRadius: 16, textAlign: 'center', boxShadow: '0 10px 30px rgba(0,0,0,0.5)', minWidth: 150}}>
                            <div style={{fontSize: '0.8rem', textTransform: 'uppercase', opacity: 0.8, fontWeight: 700}}>Player 1</div>
                            <div style={{fontSize: '1.5rem', fontWeight: 800}}>{battleContestants[0] || "?"}</div>
                        </div>
                    </div>
                    <div style={{position: 'absolute', top: '50%', right: '20px', transform: 'translateY(-50%)', zIndex: 10, transition: 'all 0.5s', opacity: battleContestants[1] ? 1 : 0.3}}>
                        <div style={{background: theme.colors[1], color: 'white', padding: '20px', borderRadius: 16, textAlign: 'center', boxShadow: '0 10px 30px rgba(0,0,0,0.5)', minWidth: 150}}>
                            <div style={{fontSize: '0.8rem', textTransform: 'uppercase', opacity: 0.8, fontWeight: 700}}>Player 2</div>
                            <div style={{fontSize: '1.5rem', fontWeight: 800}}>{battleContestants[1] || "?"}</div>
                        </div>
                    </div>
                </>
            )}

            <div ref={containerRef} className="wheel-container">
                <canvas ref={canvasRef} onClick={spin} style={{maxWidth: '100%', maxHeight: showTimer ? '55vh' : '70vh', cursor: 'pointer', filter: 'drop-shadow(0 10px 20px rgba(0,0,0,0.3))', transition: 'max-height 0.3s ease'}}/>
                
                {/* BLOOM'S WHEEL (SECOND CANVAS) */}
                {bloomMode === 'dual' && (
                    <canvas ref={canvasRef2} onClick={spin} style={{maxWidth: '100%', maxHeight: showTimer ? '55vh' : '70vh', cursor: 'pointer', filter: 'drop-shadow(0 10px 20px rgba(0,0,0,0.3))', transition: 'max-height 0.3s ease'}}/>
                )}
            </div>
            
            <button onClick={spin} disabled={isSpinning || (bloomMode !== 'solo' && names.length < 2)} className="btn btn-primary">
                {isSpinning ? (battleMode ? (battleStage === 'waiting' ? 'NEXT...' : 'SPINNING...') : 'SPINNING...') : (battleMode ? 'BATTLE SPIN!' : 'SPIN!')}
            </button>
        </div>

        {/* BATTLE MODAL */}
        {battleMode && battleStage === 'finished' && (
             <div className="modal-overlay">
                <div className="modal" style={{background: 'linear-gradient(135deg, #1e293b, #0f172a)', border: '2px solid rgba(255,255,255,0.1)'}}>
                    <h2 style={{margin: '0 0 20px 0', fontSize: '3rem', fontStyle: 'italic', fontWeight: 900, background: '-webkit-linear-gradient(#fcd34d, #f59e0b)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent'}}>VS</h2>
                    <div style={{display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 20, marginBottom: 30}}>
                        <div style={{textAlign:'center'}}>
                            <div style={{fontSize:'2rem', fontWeight:800, color: theme.colors[0]}}>{battleContestants[0]}</div>
                        </div>
                        <div style={{width: 2, height: 60, background:'rgba(255,255,255,0.2)'}}></div>
                        <div style={{textAlign:'center'}}>
                            <div style={{fontSize:'2rem', fontWeight:800, color: theme.colors[1]}}>{battleContestants[1]}</div>
                        </div>
                    </div>
                    <button onClick={() => setBattleStage('idle')} className="btn btn-primary" style={{width: '100%'}}>New Battle</button>
                </div>
             </div>
        )}

        {/* STANDARD WINNER MODAL */}
        {winner && !battleMode && (
            <div className="modal-overlay">
                <div className="modal">
                    <div style={{width: 80, height: 80, background: '#fbbf24', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', margin: '0 auto 16px auto', boxShadow: '0 0 30px rgba(251, 191, 36, 0.4)'}}><div style={{color:'#78350f'}}><Icons.Trophy/></div></div>
                    <h2 style={{margin:0, opacity: 0.6}}>The winner is</h2>
                    <div className="winner-name">{winner}</div>
                    
                    {/* BLOOM RESULT */}
                    {bloomMode === 'dual' && bloomWinner && (
                        <div style={{background: 'rgba(59, 130, 246, 0.15)', color: '#60a5fa', padding: '10px', borderRadius: 8, marginTop: -10, marginBottom: 20, fontWeight: 700}}>
                            <div style={{fontSize: '0.8rem', opacity: 0.8, textTransform:'uppercase', letterSpacing:1}}>Challenge</div>
                            <div style={{fontSize: '1.5rem'}}>{bloomWinner}</div>
                        </div>
                    )}

                    <div style={{display: 'flex', flexDirection: 'column', gap: 12}}>
                        <button onClick={() => setWinner(null)} className="btn" style={{justifyContent: 'center', background: 'rgba(128,128,128,0.2)', padding: 12}}>Keep Name</button>
                        <button onClick={removeWinner} className="btn" style={{justifyContent: 'center', background: 'rgba(239, 68, 68, 0.15)', color: '#ef4444', padding: 12}}><Icons.UserMinus/> Remove & Close</button>
                    </div>
                </div>
            </div>
        )}

        {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
        {showImport && <ImportModal onClose={() => setShowImport(false)} onImport={performImport} />}
        {showGroups && <GroupMakerModal names={names} onClose={() => setShowGroups(false)} onStartScoring={handleStartScoring} />}
    </div>
  );
}